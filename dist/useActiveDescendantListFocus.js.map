{"version":3,"file":"useActiveDescendantListFocus.js","mappings":"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","sources":["webpack://monday-style/webpack/universalModuleDefinition","webpack://monday-style/./src/hooks/useActiveDescendantListFocus/useActiveDescendantListFocusHelpers.ts","webpack://monday-style/./src/hooks/useActiveDescendantListFocus/useActiveDescendantListFocusHooks.ts","webpack://monday-style/./src/hooks/useEventListener/index.ts","webpack://monday-style/./src/hooks/useKeyEvent/index.ts","webpack://monday-style/./src/hooks/useListenFocusTriggers/index.ts","webpack://monday-style/./src/hooks/usePrevious/index.ts","webpack://monday-style/external umd \"react\"","webpack://monday-style/webpack/bootstrap","webpack://monday-style/webpack/runtime/make namespace object","webpack://monday-style/./src/style-imports.ts","webpack://monday-style/./src/hooks/useActiveDescendantListFocus/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"monday-style\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"monday-style\"] = factory(root[\"react\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__8156__) => {\nreturn ","type ActiveDependentHelper = {\r\n  isItemSelectable: (index: number) => boolean;\r\n  visualFocusItemIndex: number;\r\n  itemsCount: number;\r\n};\r\n\r\nexport function getNextSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount }: ActiveDependentHelper) {\r\n  if (visualFocusItemIndex > itemsCount - 1) return;\r\n  // Go over all the next items until found one which is selectable\r\n  for (let offset = 1; offset <= itemsCount; offset++) {\r\n    const nextIndex = (visualFocusItemIndex + offset) % itemsCount;\r\n    if (isItemSelectable(nextIndex)) {\r\n      return nextIndex;\r\n    }\r\n  }\r\n}\r\nexport function getPreviousSelectableIndex({\r\n  isItemSelectable,\r\n  visualFocusItemIndex,\r\n  itemsCount\r\n}: ActiveDependentHelper) {\r\n  for (let offset = 1; offset <= itemsCount - 1; offset++) {\r\n    let prevIndex = visualFocusItemIndex - offset;\r\n    if (prevIndex < 0) {\r\n      prevIndex = itemsCount + prevIndex;\r\n    }\r\n    if (isItemSelectable(prevIndex)) {\r\n      return prevIndex;\r\n    }\r\n  }\r\n}\r\n","import React, { MutableRefObject, useCallback, useEffect, useMemo, useRef } from \"react\";\r\nimport useKeyEvent, { UseKeyEventArgs } from \"../useKeyEvent\";\r\nimport useEventListener from \"../useEventListener\";\r\nimport usePrevious from \"../usePrevious\";\r\nimport { getNextSelectableIndex, getPreviousSelectableIndex } from \"./useActiveDescendantListFocusHelpers\";\r\nimport useListenFocusTriggers from \"../useListenFocusTriggers\";\r\n\r\nenum ArrowDirection {\r\n  UP = \"ArrowUp\",\r\n  DOWN = \"ArrowDown\",\r\n  RIGHT = \"ArrowRight\",\r\n  LEFT = \"ArrowLeft\"\r\n}\r\n\r\nconst ENTER_KEY = \"Enter\";\r\nconst SPACE_KEY = \" \";\r\n\r\nexport function useSupportArrowsKeyboardNavigation({\r\n  itemsCount,\r\n  focusedElementRef,\r\n  visualFocusItemIndex,\r\n  setVisualFocusItemIndex,\r\n  isHorizontalList,\r\n  isItemSelectable,\r\n  listenerOptions,\r\n  triggeredByKeyboard\r\n}: {\r\n  itemsCount: number;\r\n  focusedElementRef: MutableRefObject<HTMLElement>;\r\n  visualFocusItemIndex: number;\r\n  setVisualFocusItemIndex: (index: number) => void;\r\n  isHorizontalList: boolean;\r\n  isItemSelectable: (index: number) => boolean;\r\n  triggeredByKeyboard: MutableRefObject<boolean>;\r\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\r\n}) {\r\n  const nextArrow = isHorizontalList ? ArrowDirection.RIGHT : ArrowDirection.DOWN;\r\n  const backArrow = isHorizontalList ? ArrowDirection.LEFT : ArrowDirection.UP;\r\n\r\n  const onArrowKeyEvent = useCallback(\r\n    (direction: ArrowDirection) => {\r\n      // we desire to change the visual focus item only if the user pressed on the keyboard arrows keys while\r\n      // the focusedElementRef is naturally focus\r\n      if (document.activeElement !== focusedElementRef.current) {\r\n        return;\r\n      }\r\n\r\n      // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we will mark future user interactions as trigger by keyboard (until the next mouse interaction)\r\n      // that from now on the interactions are trigger by keyboard (until the next mouse interaction)\r\n      if (!triggeredByKeyboard.current) {\r\n        triggeredByKeyboard.current = true;\r\n\r\n        // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we want only to display the item\r\n        // which right now visually focus without changing it.\r\n        if (visualFocusItemIndex > -1) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      let newIndex;\r\n\r\n      // We will change the visual focused item index according to the direction of the pressed arrow\r\n      if (direction === nextArrow) {\r\n        newIndex = getNextSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\r\n      } else if (direction === backArrow) {\r\n        newIndex = getPreviousSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\r\n      }\r\n\r\n      if (newIndex > -1 && newIndex !== visualFocusItemIndex) setVisualFocusItemIndex(newIndex);\r\n    },\r\n    [\r\n      focusedElementRef,\r\n      triggeredByKeyboard,\r\n      nextArrow,\r\n      backArrow,\r\n      visualFocusItemIndex,\r\n      setVisualFocusItemIndex,\r\n      isItemSelectable,\r\n      itemsCount\r\n    ]\r\n  );\r\n  const onArrowBack = useCallback(() => {\r\n    onArrowKeyEvent(backArrow);\r\n  }, [backArrow, onArrowKeyEvent]);\r\n\r\n  const onArrowNext = useCallback(() => {\r\n    onArrowKeyEvent(nextArrow);\r\n  }, [nextArrow, onArrowKeyEvent]);\r\n\r\n  useKeyEvent({\r\n    keys: [nextArrow],\r\n    callback: onArrowNext,\r\n    ...listenerOptions\r\n  });\r\n\r\n  useKeyEvent({\r\n    keys: [backArrow],\r\n    callback: onArrowBack,\r\n    ...listenerOptions\r\n  });\r\n}\r\n\r\nexport function useSupportPressItemKeyboardNavigation({\r\n  visualFocusItemIndex,\r\n  focusedElementRef,\r\n  itemsCount,\r\n  setVisualFocusItemIndex,\r\n  onItemClick,\r\n  isItemSelectable,\r\n  listenerOptions = undefined,\r\n  isIgnoreSpaceAsItemSelection = false\r\n}: {\r\n  visualFocusItemIndex: number;\r\n  focusedElementRef: MutableRefObject<HTMLElement>;\r\n  itemsCount: number;\r\n  setVisualFocusItemIndex: (index: number) => void;\r\n  onItemClick: (event: React.MouseEvent | React.KeyboardEvent, index: number) => void;\r\n  isItemSelectable: (index: number) => boolean;\r\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\r\n  isIgnoreSpaceAsItemSelection: boolean;\r\n}) {\r\n  const pressKeys = useMemo(\r\n    () => (isIgnoreSpaceAsItemSelection ? [ENTER_KEY] : [ENTER_KEY, SPACE_KEY]),\r\n    [isIgnoreSpaceAsItemSelection]\r\n  );\r\n\r\n  const baseOnClickCallback = useCallback(\r\n    (event: React.KeyboardEvent, itemIndex: number) => {\r\n      const hasValidIndex = itemIndex >= 0 && itemIndex < itemsCount;\r\n      if (!onItemClick || !hasValidIndex || !isItemSelectable(itemIndex)) return;\r\n      if (visualFocusItemIndex !== itemIndex) setVisualFocusItemIndex(itemIndex);\r\n      onItemClick(event, itemIndex);\r\n    },\r\n    [itemsCount, onItemClick, isItemSelectable, visualFocusItemIndex, setVisualFocusItemIndex]\r\n  );\r\n\r\n  const keyboardOnSelectCallback = useCallback(\r\n    (event: React.KeyboardEvent) => {\r\n      // we desire to change the trigger the active item on click callback only if the user pressed on the keyboard arrows keys while\r\n      // the focusedElementRef is naturally focus\r\n      if (focusedElementRef.current.contains(document.activeElement)) {\r\n        baseOnClickCallback(event, visualFocusItemIndex);\r\n      }\r\n    },\r\n    [baseOnClickCallback, focusedElementRef, visualFocusItemIndex]\r\n  );\r\n\r\n  useKeyEvent({\r\n    keys: pressKeys,\r\n    callback: keyboardOnSelectCallback,\r\n    ...listenerOptions\r\n  });\r\n}\r\n\r\nexport function useCleanVisualFocusOnBlur({\r\n  focusedElementRef,\r\n  visualFocusItemIndex,\r\n  setVisualFocusItemIndex\r\n}: {\r\n  focusedElementRef: MutableRefObject<HTMLElement>;\r\n  visualFocusItemIndex: number;\r\n  setVisualFocusItemIndex: (index: number) => void;\r\n}) {\r\n  const previousFocusedElementRef = usePrevious(focusedElementRef);\r\n\r\n  const onBlurCallback = useCallback(() => {\r\n    if (visualFocusItemIndex !== -1) {\r\n      setVisualFocusItemIndex(-1);\r\n    }\r\n  }, [setVisualFocusItemIndex, visualFocusItemIndex]);\r\n\r\n  // if element unmount act like element got blur event\r\n  useEffect(() => {\r\n    // if element unmount\r\n    if (focusedElementRef?.current === null && previousFocusedElementRef?.current !== null) {\r\n      onBlurCallback();\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [focusedElementRef.current, previousFocusedElementRef, onBlurCallback]);\r\n\r\n  useEventListener({\r\n    eventName: \"blur\",\r\n    ref: focusedElementRef,\r\n    callback: onBlurCallback\r\n  });\r\n}\r\n\r\nexport function useSetDefaultItemOnFocusEvent({\r\n  focusedElementRef,\r\n  isItemSelectable,\r\n  visualFocusItemIndex,\r\n  setVisualFocusItemIndex,\r\n  itemsCount,\r\n  defaultVisualFocusItemIndex = -1\r\n}: {\r\n  focusedElementRef: MutableRefObject<HTMLElement>;\r\n  isItemSelectable: (index: number) => boolean;\r\n  visualFocusItemIndex: number;\r\n  setVisualFocusItemIndex: (index: number) => void;\r\n  itemsCount: number;\r\n  defaultVisualFocusItemIndex: number;\r\n}) {\r\n  const triggeredByKeyboard = useRef(false);\r\n\r\n  const onFocusByKeyboard = useCallback(() => {\r\n    triggeredByKeyboard.current = true;\r\n    if (visualFocusItemIndex !== defaultVisualFocusItemIndex) {\r\n      let newVisualFocusIndex;\r\n      if (isItemSelectable(defaultVisualFocusItemIndex)) {\r\n        newVisualFocusIndex = defaultVisualFocusItemIndex;\r\n      } else {\r\n        newVisualFocusIndex = getNextSelectableIndex({\r\n          isItemSelectable,\r\n          itemsCount,\r\n          visualFocusItemIndex: defaultVisualFocusItemIndex\r\n        });\r\n      }\r\n      setVisualFocusItemIndex(newVisualFocusIndex);\r\n    }\r\n  }, [\r\n    defaultVisualFocusItemIndex,\r\n    isItemSelectable,\r\n    itemsCount,\r\n    setVisualFocusItemIndex,\r\n    triggeredByKeyboard,\r\n    visualFocusItemIndex\r\n  ]);\r\n  const onFocusByMouse = useCallback(() => {\r\n    triggeredByKeyboard.current = false;\r\n  }, [triggeredByKeyboard]);\r\n  useListenFocusTriggers({ ref: focusedElementRef, onFocusByKeyboard, onFocusByMouse });\r\n\r\n  return { triggeredByKeyboard };\r\n}\r\n\r\nexport function useKeepFocusOnItemWhenListChanged({\r\n  visualFocusItemIndex,\r\n  itemsIds,\r\n  isItemSelectable,\r\n  setVisualFocusItemIndex\r\n}: {\r\n  visualFocusItemIndex: number;\r\n  itemsIds: string[];\r\n  isItemSelectable: (index: number) => boolean;\r\n  setVisualFocusItemIndex: (index: number) => void;\r\n}) {\r\n  const prevItemIds = usePrevious(itemsIds);\r\n\r\n  // When item list changed, keep the focus on the same item\r\n  useEffect(() => {\r\n    // When the list is changing the index of the focused item is point to a different item then before and\r\n    // this is why we want to search for the new index of the item and change the index to point to it.\r\n    let overrideIndexAfterListChanged;\r\n    const isListChanged = prevItemIds !== undefined && prevItemIds !== itemsIds;\r\n    if (isListChanged && prevItemIds !== undefined && visualFocusItemIndex !== -1) {\r\n      const focusedItemId = prevItemIds[visualFocusItemIndex];\r\n      overrideIndexAfterListChanged = itemsIds.indexOf(focusedItemId);\r\n    } else {\r\n      overrideIndexAfterListChanged = visualFocusItemIndex;\r\n    }\r\n\r\n    if (overrideIndexAfterListChanged !== visualFocusItemIndex) {\r\n      if (isItemSelectable(overrideIndexAfterListChanged)) {\r\n        setVisualFocusItemIndex(overrideIndexAfterListChanged);\r\n      } else {\r\n        const closestSelectableIndex = getNextSelectableIndex({\r\n          isItemSelectable,\r\n          visualFocusItemIndex: overrideIndexAfterListChanged,\r\n          itemsCount: itemsIds.length\r\n        });\r\n        setVisualFocusItemIndex(closestSelectableIndex);\r\n      }\r\n    }\r\n  }, [visualFocusItemIndex, itemsIds, isItemSelectable, setVisualFocusItemIndex, prevItemIds]);\r\n}\r\n","import { RefObject, useEffect } from \"react\";\r\nimport { GenericEventCallback } from \"../../types/events\";\r\n\r\nexport default function useEventListener({\r\n  eventName,\r\n  callback,\r\n  ref,\r\n  capture = false\r\n}: {\r\n  eventName: keyof HTMLElementEventMap | string;\r\n  callback: GenericEventCallback;\r\n  ref: RefObject<HTMLElement | Document>;\r\n  capture?: boolean;\r\n}): void {\r\n  useEffect(() => {\r\n    const refElement = ref && ref.current;\r\n    if (!refElement) return;\r\n    const listenerOptions = { capture };\r\n\r\n    refElement.addEventListener(eventName, callback, listenerOptions);\r\n\r\n    return () => {\r\n      refElement.removeEventListener(eventName, callback, listenerOptions);\r\n    };\r\n  }, [eventName, ref, callback, capture]);\r\n}\r\n","import { RefObject, useCallback, useRef } from \"react\";\r\nimport useEventListener from \"../useEventListener\";\r\nimport { GenericEventCallback } from \"../../types/events\";\r\n\r\nconst CTRL_OR_META = \"ctrlOrMetaKey\";\r\n\r\nenum Modifier {\r\n  ALT = \"altKey\",\r\n  META = \"metaKey\",\r\n  CTRL = \"ctrlKey\",\r\n  SHIFT = \"shiftKey\",\r\n  CTRL_OR_META = \"ctrlOrMetaKey\"\r\n}\r\n\r\nconst checkModifierInEvent = (event: KeyboardEvent, modifier: Modifier) => {\r\n  if (modifier === Modifier.CTRL_OR_META) {\r\n    return event.ctrlKey || event.metaKey;\r\n  }\r\n\r\n  return event[modifier];\r\n};\r\nconst checkWithoutModifierInEvent = (event: KeyboardEvent) => {\r\n  return !Object.values(useKeyEvent.modifiers).some((m: Modifier) => {\r\n    if (m !== CTRL_OR_META) {\r\n      return !!event[m];\r\n    }\r\n  });\r\n};\r\n\r\nexport interface UseKeyEventArgs {\r\n  keys: KeyboardEvent[\"key\"][];\r\n  callback: GenericEventCallback;\r\n  modifier?: Modifier;\r\n  keyEventName?: string;\r\n  withoutAnyModifier?: boolean;\r\n  ref?: RefObject<HTMLElement | Document>;\r\n  ignoreDocumentFallback?: boolean;\r\n  capture?: boolean;\r\n  preventDefault?: boolean;\r\n  stopPropagation?: boolean;\r\n}\r\n\r\nexport default function useKeyEvent({\r\n  keys = [],\r\n  callback,\r\n  modifier,\r\n  withoutAnyModifier,\r\n  ref,\r\n  ignoreDocumentFallback = false,\r\n  capture = false,\r\n  preventDefault = false,\r\n  stopPropagation = false,\r\n  keyEventName = \"keydown\" // need keydown and not keyup to prevent scrolling with prevent default, for example during menu keyboard navigation\r\n}: UseKeyEventArgs) {\r\n  const documentRef = useRef(document.body);\r\n  const onKeyUpPress = useCallback(\r\n    (event: KeyboardEvent) => {\r\n      const { key } = event;\r\n      if (!keys.includes(key)) {\r\n        return;\r\n      }\r\n      if (modifier && !checkModifierInEvent(event, modifier)) {\r\n        return;\r\n      }\r\n      if (withoutAnyModifier && !checkWithoutModifierInEvent(event)) {\r\n        return;\r\n      }\r\n\r\n      if (preventDefault) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      if (stopPropagation) {\r\n        event.stopPropagation();\r\n      }\r\n\r\n      callback(event);\r\n    },\r\n    [keys, modifier, withoutAnyModifier, preventDefault, stopPropagation, callback]\r\n  );\r\n\r\n  let listenerRef;\r\n\r\n  if (ref) {\r\n    listenerRef = ref;\r\n  } else if (ignoreDocumentFallback) {\r\n    listenerRef = null;\r\n  } else {\r\n    listenerRef = documentRef;\r\n  }\r\n\r\n  useEventListener({\r\n    eventName: keyEventName,\r\n    callback: onKeyUpPress,\r\n    ref: listenerRef,\r\n    capture\r\n  });\r\n}\r\n\r\nuseKeyEvent.modifiers = Modifier;\r\n","import useEventListener from \"../useEventListener\";\r\nimport { RefObject, useCallback, useRef } from \"react\";\r\n\r\nexport default function useListenFocusTriggers({\r\n  ref,\r\n  onFocusByKeyboard,\r\n  onFocusByMouse\r\n}: {\r\n  ref: RefObject<HTMLElement>;\r\n  onFocusByKeyboard?: (event: FocusEvent) => void;\r\n  onFocusByMouse?: (event: FocusEvent) => void;\r\n}) {\r\n  const isElementMouseDown = useRef(false);\r\n\r\n  const onMouseDown = useCallback(() => {\r\n    isElementMouseDown.current = true;\r\n  }, [isElementMouseDown]);\r\n\r\n  const onFocus = useCallback(\r\n    (e: FocusEvent) => {\r\n      // if focus triggered by mouse down, call onFocusByMouse\r\n      if (isElementMouseDown.current) {\r\n        onFocusByMouse?.(e);\r\n      } else {\r\n        onFocusByKeyboard?.(e);\r\n      }\r\n    },\r\n    [onFocusByKeyboard, onFocusByMouse]\r\n  );\r\n  const onMouseUp = useCallback(() => {\r\n    isElementMouseDown.current = false;\r\n  }, [isElementMouseDown]);\r\n\r\n  useEventListener({\r\n    eventName: \"mousedown\",\r\n    ref,\r\n    callback: onMouseDown\r\n  });\r\n\r\n  useEventListener({\r\n    eventName: \"focus\",\r\n    ref,\r\n    callback: onFocus\r\n  });\r\n\r\n  useEventListener({\r\n    eventName: \"mouseup\",\r\n    ref,\r\n    callback: onMouseUp\r\n  });\r\n}\r\n","import { useLayoutEffect, useRef } from \"react\";\r\n\r\nexport default function usePrevious<Type>(value: Type): Type {\r\n  const ref = useRef(undefined);\r\n  useLayoutEffect(() => {\r\n    ref.current = value;\r\n  });\r\n  return ref.current;\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__8156__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import \"monday-ui-style/dist/index.min.css\";\r\n","import React, { useMemo, useState, useCallback, MutableRefObject } from \"react\";\r\nimport {\r\n  useSupportArrowsKeyboardNavigation,\r\n  useSupportPressItemKeyboardNavigation,\r\n  useSetDefaultItemOnFocusEvent,\r\n  useKeepFocusOnItemWhenListChanged,\r\n  useCleanVisualFocusOnBlur\r\n} from \"./useActiveDescendantListFocusHooks\";\r\n\r\nenum Role {\r\n  APPLICATION = \"application\",\r\n  COMBOBOX = \"combobox\",\r\n  COMPOSITE = \"composite\",\r\n  GROUP = \"group\",\r\n  TEXTBOX = \"textbox\",\r\n  MENU = \"menu\"\r\n}\r\n\r\nfunction useActiveDescendantListFocus({\r\n  focusedElementRef, // the reference for the component that listens to keyboard\r\n  itemsIds,\r\n  isItemSelectable,\r\n  onItemClick,\r\n  defaultVisualFocusFirstIndex = false,\r\n  focusedElementRole = Role.GROUP,\r\n  isHorizontalList = false,\r\n  isIgnoreSpaceAsItemSelection = false,\r\n  useDocumentEventListeners = false,\r\n  ignoreDocumentFallback = false\r\n}: {\r\n  focusedElementRef: MutableRefObject<HTMLElement>;\r\n  itemsIds: string[];\r\n  isItemSelectable: (index: number) => boolean;\r\n  onItemClick: (event: React.KeyboardEvent | React.MouseEvent, index: number) => void;\r\n  defaultVisualFocusFirstIndex?: boolean;\r\n  focusedElementRole?: Role;\r\n  isHorizontalList?: boolean;\r\n  isIgnoreSpaceAsItemSelection?: boolean;\r\n  useDocumentEventListeners?: boolean;\r\n  ignoreDocumentFallback?: boolean;\r\n}) {\r\n  const defaultVisualFocusItemIndex = defaultVisualFocusFirstIndex ? 0 : -1;\r\n  const itemsCount = itemsIds.length;\r\n  const [visualFocusItemIndex, setVisualFocusItemIndex] = useState<number>(-1);\r\n  const visualFocusItemId = itemsIds[visualFocusItemIndex];\r\n\r\n  const listenerOptions = useMemo(() => {\r\n    if (useDocumentEventListeners) {\r\n      return ignoreDocumentFallback ? { ignoreDocumentFallback } : undefined;\r\n    }\r\n\r\n    return {\r\n      ref: focusedElementRef,\r\n      preventDefault: true,\r\n      stopPropagation: true\r\n    };\r\n  }, [useDocumentEventListeners, focusedElementRef, ignoreDocumentFallback]);\r\n\r\n  const { triggeredByKeyboard } = useSetDefaultItemOnFocusEvent({\r\n    focusedElementRef,\r\n    isItemSelectable,\r\n    visualFocusItemIndex,\r\n    setVisualFocusItemIndex,\r\n    itemsCount,\r\n    defaultVisualFocusItemIndex\r\n  });\r\n\r\n  const setVisualFocusItemId = useCallback(\r\n    (visualFocusItemId: string, isTriggeredByKeyboard: boolean) => {\r\n      triggeredByKeyboard.current = isTriggeredByKeyboard;\r\n      const itemIndex = itemsIds.indexOf(visualFocusItemId);\r\n      if (itemIndex > -1 && itemIndex !== visualFocusItemIndex) {\r\n        setVisualFocusItemIndex(itemIndex);\r\n      }\r\n    },\r\n    [itemsIds, triggeredByKeyboard, visualFocusItemIndex]\r\n  );\r\n\r\n  useSupportArrowsKeyboardNavigation({\r\n    itemsCount,\r\n    focusedElementRef,\r\n    visualFocusItemIndex,\r\n    setVisualFocusItemIndex,\r\n    triggeredByKeyboard,\r\n    isHorizontalList,\r\n    isItemSelectable,\r\n    listenerOptions\r\n  });\r\n\r\n  useSupportPressItemKeyboardNavigation({\r\n    visualFocusItemIndex,\r\n    itemsCount,\r\n    focusedElementRef,\r\n    setVisualFocusItemIndex,\r\n    onItemClick,\r\n    isItemSelectable,\r\n    listenerOptions,\r\n    isIgnoreSpaceAsItemSelection\r\n  });\r\n\r\n  useKeepFocusOnItemWhenListChanged({\r\n    visualFocusItemIndex,\r\n    itemsIds,\r\n    isItemSelectable,\r\n    setVisualFocusItemIndex\r\n  });\r\n\r\n  useCleanVisualFocusOnBlur({ focusedElementRef, visualFocusItemIndex, setVisualFocusItemIndex });\r\n\r\n  // this callback function is not needed anymore (the developer does not need to replace  the element's on click with this callback).\r\n  // we keep it for backward compatibility\r\n  const backwardCompatibilityCreateOnClickCallback = useCallback(\r\n    (itemIndex: number) => (event: React.KeyboardEvent | React.MouseEvent) => onItemClick(event, itemIndex),\r\n    [onItemClick]\r\n  );\r\n  return {\r\n    visualFocusItemIndex: triggeredByKeyboard.current ? visualFocusItemIndex : undefined,\r\n    visualFocusItemId: triggeredByKeyboard.current ? visualFocusItemId : undefined,\r\n    focusedElementProps: {\r\n      \"aria-activedescendant\": triggeredByKeyboard.current ? visualFocusItemId : undefined,\r\n      role: focusedElementRole\r\n    },\r\n    // this callback function is not needed anymore (the developer does not need to replace  the element's on click with this callback).\r\n    // we keep it for backward compatibility\r\n    onItemClickCallback: onItemClick,\r\n    createOnItemClickCallback: backwardCompatibilityCreateOnClickCallback,\r\n    setVisualFocusItemId\r\n  };\r\n}\r\n\r\nuseActiveDescendantListFocus.roles = Role;\r\n\r\nexport default useActiveDescendantListFocus;\r\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__8156__","isItemSelectable","visualFocusItemIndex","itemsCount","offset","nextIndex","prevIndex","ArrowDirection","ENTER_KEY","focusedElementRef","setVisualFocusItemIndex","isHorizontalList","listenerOptions","triggeredByKeyboard","nextArrow","RIGHT","DOWN","backArrow","LEFT","UP","onArrowKeyEvent","useCallback","direction","document","activeElement","current","newIndex","getNextSelectableIndex","getPreviousSelectableIndex","onArrowBack","onArrowNext","keys","callback","onItemClick","isIgnoreSpaceAsItemSelection","pressKeys","useMemo","baseOnClickCallback","event","itemIndex","keyboardOnSelectCallback","contains","previousFocusedElementRef","onBlurCallback","useEffect","eventName","ref","defaultVisualFocusItemIndex","useRef","onFocusByKeyboard","newVisualFocusIndex","onFocusByMouse","itemsIds","prevItemIds","overrideIndexAfterListChanged","undefined","focusedItemId","indexOf","closestSelectableIndex","length","capture","refElement","addEventListener","removeEventListener","Modifier","useKeyEvent","modifier","withoutAnyModifier","ignoreDocumentFallback","preventDefault","stopPropagation","keyEventName","documentRef","body","onKeyUpPress","key","includes","CTRL_OR_META","ctrlKey","metaKey","checkModifierInEvent","Object","values","modifiers","some","m","checkWithoutModifierInEvent","listenerRef","isElementMouseDown","onMouseDown","onFocus","e","onMouseUp","value","useLayoutEffect","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","r","Symbol","toStringTag","defineProperty","Role","useActiveDescendantListFocus","defaultVisualFocusFirstIndex","focusedElementRole","GROUP","useDocumentEventListeners","useState","visualFocusItemId","useSetDefaultItemOnFocusEvent","setVisualFocusItemId","isTriggeredByKeyboard","useSupportArrowsKeyboardNavigation","useSupportPressItemKeyboardNavigation","useKeepFocusOnItemWhenListChanged","useCleanVisualFocusOnBlur","backwardCompatibilityCreateOnClickCallback","focusedElementProps","role","onItemClickCallback","createOnItemClickCallback","roles"],"sourceRoot":""}